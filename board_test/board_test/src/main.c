/**
 * \file
 *
 * \brief Getting Started Application.
 *
 * Copyright (c) 2011-2015 Atmel Corporation. All rights reserved.
 *
 * \asf_license_start
 *
 * \page License
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice,
 *    this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * 3. The name of Atmel may not be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * 4. This software may only be redistributed and used in connection with an
 *    Atmel microcontroller product.
 *
 * THIS SOFTWARE IS PROVIDED BY ATMEL "AS IS" AND ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
 * EXPRESSLY AND SPECIFICALLY DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
 * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 *
 * \asf_license_stop
 *
 */

/**
 * \mainpage Getting Started Application
 *
 * \section Purpose
 *
 * The Getting Started example will help new users get familiar with Atmel's
 * SAM family of microcontrollers. This basic application shows the startup
 * sequence of a chip and how to use its core peripherals.
 *
 * \section Requirements
 *
 * This package can be used with SAM evaluation kits.
 *
 * \section Description
 *
 * The demonstration program makes the LED(s) on the board blink at a fixed rate.
 * This rate is generated by using Time tick timer. The blinking can be stopped
 * using the push button.
 *
 * \section Usage
 *
 * -# Build the program and download it inside the evaluation board.
 * -# On the computer, open and configure a terminal application
 *    (e.g. HyperTerminal on Microsoft Windows) with these settings:
 *   - 115200 bauds
 *   - 8 bits of data
 *   - No parity
 *   - 1 stop bit
 *   - No flow control
 * -# Start the application.
 * -# The LED(s) should start blinking on the board. In the terminal window, the
 *    following text should appear (values depend on the board and chip used):
 *    \code
    -- Getting Started Example xxx --
    -- xxxxxx-xx
    -- Compiled: xxx xx xxxx xx:xx:xx --
\endcode
 * -# Pressing and release button 1 should make one LED stop & restart
 *    blinking.
 * -# If the button 2 available, pressing button 2 should make the other LED
 *    stop & restart blinking.
 *
 */
/*
 * Support and FAQ: visit <a href="http://www.atmel.com/design-support/">Atmel Support</a>
 */

#include "asf.h"
#include "stdio_serial.h"
#include "conf_board.h"
#include "conf_clock.h"
#include "uart.h"
#include "time.h"
#include "button.h"
#include "rs485.h"
#include "ptp.h"
#include "test_board.h"

#include "log.h"
#define LOG_TAG        "Main"
#define LOG_LEVEL     LOG_LEVEL_DEBUG



#ifdef __cplusplus
extern "C" {
#endif


static void read_serial(void){
    uint32_t val;
    int c = getchar();
    if (c != -1){
        switch (c){
            case 'a':
            if (ptp_adc_get(ptp_a, &val)){
                LOG_DEBUG("ADC: %lu", val);
            } else {
                LOG_ERROR("ADC read failed");
            }
            break;
            case 'r':
            ptp_set_mode(ptp_a, PTP_MODE_TX);
            break;
            case 't':
            ptp_set_mode(ptp_a, PTP_MODE_RX);
            break;
            case 'e':
            ptp_set_mode(ptp_a, PTP_MODE_RX_TX);
            break;
            case 'z':
            ptp_set_mode(ptp_a, PTP_MODE_HI_Z);
            break;
            case 'h':
            ptp_set_mode(ptp_a, PTP_MODE_HIGH);
            break;
            case 'l':
            ptp_set_mode(ptp_a, PTP_MODE_LOW);
            break;
            case 'u':
            ptp_set_mode(ptp_a, PTP_MODE_PULL_UP_WEAK);
            break;
            case 'p':
            ptp_set_mode(ptp_a, PTP_MODE_PULL_UP_STRONG);
            break;
            case 'd':
            ptp_set_mode(ptp_a, PTP_MODE_PULL_DOWN_WEAK);
            break;
            case 'w':
            ptp_set_mode(ptp_a, PTP_MODE_PULL_DOWN_STRONG);
            break;

            case 'A':
            if (ptp_adc_get(ptp_b, &val)){
                LOG_DEBUG("ADC: %lu", val);
            } else {
                LOG_ERROR("ADC read failed");
            }
            break;
            case 'R':
            ptp_set_mode(ptp_b, PTP_MODE_TX);
            break;
            case 'T':
            ptp_set_mode(ptp_b, PTP_MODE_RX);
            break;
            case 'E':
            ptp_set_mode(ptp_b, PTP_MODE_RX_TX);
            break;
            case 'Z':
            ptp_set_mode(ptp_b, PTP_MODE_HI_Z);
            break;
            case 'H':
            ptp_set_mode(ptp_b, PTP_MODE_HIGH);
            break;
            case 'L':
            ptp_set_mode(ptp_b, PTP_MODE_LOW);
            break;
            case 'U':
            ptp_set_mode(ptp_b, PTP_MODE_PULL_UP_WEAK);
            break;
            case 'P':
            ptp_set_mode(ptp_b, PTP_MODE_PULL_UP_STRONG);
            break;
            case 'D':
            ptp_set_mode(ptp_b, PTP_MODE_PULL_DOWN_WEAK);
            break;
            case 'W':
            ptp_set_mode(ptp_b, PTP_MODE_PULL_DOWN_STRONG);
            break;

            default:
            LOG_INFO("?");
            break;
        }
    }
}    


int main(void)
{
    sysclk_init();
    board_init();

    uart_stdio_init(CONSOLE_UART, 115200);

    TEST_LOG_INFO(){
        printf("\n\r\tFirmware Poppy-com built on %s at %s\n\r", __DATE__, __TIME__ );
    }

    if (SysTick_Config(sysclk_get_cpu_hz() / 1000)) {
        LOG_ERROR("systic config failed");
        while (1);
    }

    rs485_init();
    ptp_init();
    
    ptp_set_mode(ptp_a, PTP_MODE_RX);
    ptp_set_mode(ptp_b, PTP_MODE_RX);
    
    while (1){
        read_serial();
        delay_ms(1);
    }        
    
    
    
    
    
    
//     
//     
//     char my_char = 'r';
//     char ptp_char_a = 'a';  
//     char ptp_char_b = 'b';
// 
//     while (1) {
//         rs485_set_dir(HALF_DUPLEX_BOTH);
//          
//         delay_ms(1); // TODO wait for event when it's done writing
//         
//         rs485_write(my_char);
//         
//         delay_ms(1); // TODO wait for event when it's done writing
//         rs485_set_dir(HALF_DUPLEX_RX);
//         
//         uint32_t now = get_tick();
//         while ( get_tick() - now < 500 ){
//             uint32_t c;
//             for(uint8_t i = 0; i< 5; i++){
//                 if (rs485_read(&c) == 0){
//                     if (c != my_char){
//                         LOG_INFO("RS485: %c", (uint8_t)c);
//                     }
//                 }
//                 delay_ms(1);
//             }            
//             
//             ptp_set_mode( ptp_b, PTP_MODE_TX);
//             delay_ms(1);
//             ptp_write(ptp_b, ptp_char_b);
//             delay_ms(1);
//             ptp_set_mode( ptp_b, PTP_MODE_RX);
// 
//             for(uint8_t i = 0; i< 5; i++){
//                 if (ptp_read(ptp_a, &c) == 0){
//                     //if (c != ptp_char_a){
//                     LOG_INFO("PTP_A: %c", (uint8_t)c);
//                     //}
//                 }
//             delay_ms(1);
//             }
//             
//             
//             ptp_set_mode( ptp_a, PTP_MODE_TX);
//             delay_ms(1);
//             ptp_write(ptp_a, ptp_char_a);
//             delay_ms(1);
//             ptp_set_mode( ptp_a, PTP_MODE_RX);
//         
//             for(uint8_t i = 0; i< 5; i++){
//                 if (ptp_read(ptp_b, &c) == 0){
//                     //if (c != ptp_char_b){
//                     LOG_INFO("PTP_B: %c", (uint8_t)c);
//                     //}
//                 }
//                 delay_ms(1);
//             }
//         }
//     }
}

#ifdef __cplusplus
}
#endif
/**
 * \file
 *
 * \brief Getting Started Application.
 *
 * Copyright (c) 2011-2015 Atmel Corporation. All rights reserved.
 *
 * \asf_license_start
 *
 * \page License
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice,
 *    this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * 3. The name of Atmel may not be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * 4. This software may only be redistributed and used in connection with an
 *    Atmel microcontroller product.
 *
 * THIS SOFTWARE IS PROVIDED BY ATMEL "AS IS" AND ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
 * EXPRESSLY AND SPECIFICALLY DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
 * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 *
 * \asf_license_stop
 *
 */

/**
 * \mainpage Getting Started Application
 *
 * \section Purpose
 *
 * The Getting Started example will help new users get familiar with Atmel's
 * SAM family of microcontrollers. This basic application shows the startup
 * sequence of a chip and how to use its core peripherals.
 *
 * \section Requirements
 *
 * This package can be used with SAM evaluation kits.
 *
 * \section Description
 *
 * The demonstration program makes the LED(s) on the board blink at a fixed rate.
 * This rate is generated by using Time tick timer. The blinking can be stopped
 * using the push button.
 *
 * \section Usage
 *
 * -# Build the program and download it inside the evaluation board.
 * -# On the computer, open and configure a terminal application
 *    (e.g. HyperTerminal on Microsoft Windows) with these settings:
 *   - 115200 bauds
 *   - 8 bits of data
 *   - No parity
 *   - 1 stop bit
 *   - No flow control
 * -# Start the application.
 * -# The LED(s) should start blinking on the board. In the terminal window, the
 *    following text should appear (values depend on the board and chip used):
 *    \code
    -- Getting Started Example xxx --
    -- xxxxxx-xx
    -- Compiled: xxx xx xxxx xx:xx:xx --
\endcode
 * -# Pressing and release button 1 should make one LED stop & restart
 *    blinking.
 * -# If the button 2 available, pressing button 2 should make the other LED
 *    stop & restart blinking.
 *
 */
/*
 * Support and FAQ: visit <a href="http://www.atmel.com/design-support/">Atmel Support</a>
 */
/*
#include "stdio_serial.h"
#include "conf_board.h"
#include "conf_clock.h"
#include "uart.h"
#include "button.h"
#include "ptp.h"*/
#include "test_board.h"
#include "asf.h"
#include "time.h"
#include "rs485.h"


#include "poppyNetwork.h"
#include "context.h"
#include "cmd.h"

#include "log.h"
#define LOG_TAG        "Main"
#define LOG_LEVEL     LOG_LEVEL_DEBUG



#ifdef __cplusplus
extern "C" {
#endif

int test_value = 0;
unsigned short target_value = 0;

typedef enum {
    TARGET_CMD = WRITE_ID,
    TEST_CMD = PROTOCOL_CMD_NB,
    NO_OVERLAP_TARGET_CMD,
    MODULE_PROTOCOL_NB
}module_register_t;

void rx_cb(msg_t *msg);

void rx_cb(msg_t *msg) {
    switch (msg->header.cmd) {
        case TEST_CMD :
            //LOG_DEBUG("MSG received and i write to do a tempo!!!!");
            poppyNetwork_send(msg);
            //LOG_DEBUG("MSG sent");
        break;
        case TARGET_CMD :
        case NO_OVERLAP_TARGET_CMD:
            target_value = msg->header.target;
        break;
        default :
            test_value = 0;
        break;
    }
}

static void read_serial(void){
    // uint32_t val;
    msg_t msg;
    int c = getchar();
    if (c != -1){
        switch (c){
            /*case 'a':
            if (ptp_adc_get(ptp_a, &val)){
                LOG_DEBUG("ADC: %lu", val);
            } else {
                LOG_ERROR("ADC read failed");
            }
            break;
            case 'r':
            ptp_set_mode(ptp_a, PTP_MODE_TX);
            break;
            case 't':
            ptp_set_mode(ptp_a, PTP_MODE_RX);
            break;
            case 'e':
            ptp_set_mode(ptp_a, PTP_MODE_RX_TX);
            break;
            case 'z':
            ptp_set_mode(ptp_a, PTP_MODE_HI_Z);
            break;
            case 'h':
            ptp_set_mode(ptp_a, PTP_MODE_HIGH);
            break;
            case 'l':
            ptp_set_mode(ptp_a, PTP_MODE_LOW);
            break;
            case 'u':
            ptp_set_mode(ptp_a, PTP_MODE_PULL_UP_WEAK);
            break;
            case 'p':
            ptp_set_mode(ptp_a, PTP_MODE_PULL_UP_STRONG);
            break;
            case 'd':
            ptp_set_mode(ptp_a, PTP_MODE_PULL_DOWN_WEAK);
            break;
            case 'w':
            ptp_set_mode(ptp_a, PTP_MODE_PULL_DOWN_STRONG);
            break;

            case 'A':
            if (ptp_adc_get(ptp_b, &val)){
                LOG_DEBUG("ADC: %lu", val);
            } else {
                LOG_ERROR("ADC read failed");
            }
            break;
            case 'R':
            ptp_set_mode(ptp_b, PTP_MODE_TX);
            break;
            case 'T':
            ptp_set_mode(ptp_b, PTP_MODE_RX);
            break;
            case 'E':
            ptp_set_mode(ptp_b, PTP_MODE_RX_TX);
            break;
            case 'Z':
            ptp_set_mode(ptp_b, PTP_MODE_HI_Z);
            break;
            case 'H':
            ptp_set_mode(ptp_b, PTP_MODE_HIGH);
            break;
            case 'L':
            ptp_set_mode(ptp_b, PTP_MODE_LOW);
            break;
            case 'U':
            ptp_set_mode(ptp_b, PTP_MODE_PULL_UP_WEAK);
            break;
            case 'P':
            ptp_set_mode(ptp_b, PTP_MODE_PULL_UP_STRONG);
            break;
            case 'D':
            ptp_set_mode(ptp_b, PTP_MODE_PULL_DOWN_WEAK);
            break;
            case 'W':
            ptp_set_mode(ptp_b, PTP_MODE_PULL_DOWN_STRONG);
            break;*/

            // RS485 tests
            case 's':
                msg.header.cmd = TEST_CMD;
                msg.header.target = ctx.id;
                msg.header.target_mode = ID;
                msg.header.size = 2;
                msg.data[0] = 0xCA;
                msg.data[1] = 0xFE;
                LOG_INFO("MSG sent");
                poppyNetwork_send(&msg);
            break;

            default:
            LOG_INFO("?");
            break;
        }
    }
}    


int main(void)
{
    uint32_t c;
    //msg_t msg;

	ioport_set_pin_dir(DBG_PIN_1, IOPORT_DIR_OUTPUT);
	ioport_set_pin_dir(DBG_PIN_2, IOPORT_DIR_OUTPUT);

    poppyNetwork_init(rx_cb);


UP1;DW1;
UP1;DW1;
UP1;DW1;
UP2;DW2;
UP2;DW2;



    while (1){
        read_serial();
        /*for(unsigned int i = 0; i< 1000; i++) {
            if (rs485_read(&c) == 0){
				LOG_INFO("plop");
                if (c) {
                    LOG_INFO("RS485: %c", (uint8_t)c);
                    ctx.data_cb((volatile unsigned char*)&c);
					c = 0;
                }
                delay_ms(0.01);
            }
        }*/ 
        delay_ms(1);
    }        
    
    
    
    
    
    
//     
//     
//     char my_char = 'r';
//     char ptp_char_a = 'a';  
//     char ptp_char_b = 'b';
// 
/*    while (1) {
		
		delay_ms(100); // TODO wait for event when it's done writing
        rs485_set_dir(HALF_DUPLEX_BOTH);
         
        delay_ms(1); // TODO wait for event when it's done writing
        msg.header.cmd = TEST_CMD;
        msg.header.target = ctx.id;
        msg.header.target_mode = ID;
        msg.header.size = 2;
        msg.data[0] = 0xCA;
        msg.data[1] = 0xFE;
        LOG_DEBUG("begin");
        poppyNetwork_send(&msg);
        rs485_set_dir(HALF_DUPLEX_RX);
        delay_ms(1); // TODO wait for event when it's done writing
        
        uint32_t now = get_tick();
        while ( get_tick() - now < 500 ){
            uint32_t c = 0xFFFFFF;
            if (rs485_read(&c) == 0){
                //LOG_INFO("plop");
                if (c != 0xFFFFFF) {
                    //LOG_INFO("RS485: %02X", (uint8_t)c);
                    ctx.data_cb((volatile unsigned char*)&c);
                    c = 0xFFFFFF;
                }
                //delay_ms(1);
            }         
        }
    }*/
}

#ifdef __cplusplus
}
#endif